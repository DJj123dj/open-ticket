///////////////////////////////////////
//ACTION MODULE
///////////////////////////////////////
import { ODId, ODManager, ODValidId, ODSystemError, ODManagerData } from "./base"
import { ODWorkerManager, ODWorkerCallback, ODWorker } from "./worker"
import { ODDebugger } from "./console"

/**## ODActionImplementation `class`
 * This is an Open Ticket action implementation.
 * 
 * It is a basic implementation of the `ODWorkerManager` used by all `ODAction` classes.
 * 
 * This class can't be used stand-alone & needs to be extended from!
 */
export class ODActionImplementation<Source extends string,Params extends object,Result extends object> extends ODManagerData {
    /**The manager that has all workers of this implementation */
    workers: ODWorkerManager<object,Source,Params>

    constructor(id:ODValidId, callback?:ODWorkerCallback<object,Source,Params>, priority?:number, callbackId?:ODValidId){
        super(id)
        this.workers = new ODWorkerManager("descending")
        if (callback) this.workers.add(new ODWorker(callbackId ? callbackId : id,priority ?? 0,callback))
    }
    /**Execute all workers & return the result. */
    async run(source:Source, params:Params): Promise<Partial<Result>> {
        throw new ODSystemError("Tried to build an unimplemented ODResponderImplementation")
    }
}

/**## ODActionManager `class`
 * This is an Open Ticket action manager.
 * 
 * It contains all Open Ticket actions. You can compare actions with some sort of "procedure".
 * It's a complicated task that is divided into multiple functions.
 * 
 * Some examples are `ticket-creation`, `ticket-closing`, `ticket-claiming`, ...
 * 
 * It's recommended to use this system in combination with Open Ticket responders!
 */
export class ODActionManager extends ODManager<ODAction<string,{},{}>> {
    constructor(debug:ODDebugger){
        super(debug,"action")
    }
}

export class ODAction<Source extends string,Params extends object,Result extends object> extends ODActionImplementation<Source,Params,Result> {
    /**Run this action */
    async run(source:Source, params:Params): Promise<Partial<Result>> {
        //create instance
        const instance = {}
        
        //wait for workers to finish
        await this.workers.executeWorkers(instance,source,params)

        //return data generated by workers
        return instance
    }
}